# 進捗報告（6/30）

15232027 城戸和輝

## 1.SSH接続
windowsパソコンを使用して臨んだが以前gitを導入したときにsshができるようなっていて `ssh-keygen` で作成した鍵を所持していた。この鍵とこれまた既に使っていたRLoginでログイン用サーバーにSSH接続することができた。

### 演習問題1:コンパイルと実行
プログラムを作成し、実行した。正しい結果になることを確認した。

プログラム:
```c
#include<stdio.h>
void  main()
{
printf("Hello!\n");
}
```

実行結果:
```sh
u15232027@ryzen0:~$ ./a.out
Hello!
```

## 2.ジョブ管理システム
OpenPBSを用いてjob1.shを計算サーバで実行した。

### 演習問題2:ジョブの投入
ジョブの投入とキューの状態:
```sh
u15232027@ryzen0:~$ qsub job1.sh
3058.ryzen0
u15232027@ryzen0:~$ qstat
Job id            Name             User              Time Use S Queue
----------------  ---------------- ----------------  -------- - -----
3058.ryzen0       job1.sh          u15232027         00:00:00 R q16       
```

標準出力の出力結果:
```sh
u15232027@ryzen0:~$ cat job1.sh.o3057
Tue Jun 30 07:06:46 UTC 2020
Tue Jun 30 07:06:51 UTC 2020
ryzen1
u15232027
```

## 3.OpenMPで並列化
円の面積を近似で求める簡単なプログラム(area.c)をOpenMPによる並列化を行い,計算サーバで実行する。

### 演習問題3:並列プログラムをジョブで実行
area.cの一つ目のfor文の前に下記のディレクティブを追加した。

```c
#pragma omp parallel for private(j,x,y,s1) reduction(+:s)
```

計算サーバ用のジョブスクリプトを作成した。

run.sh(逐次処理でのプログラム):

```sh
#!/bin/bash
echo "# Serial processing"
~/area
```

run1.sh(1コアでの実行):

```sh
#!/bin/bash
echo "# Parallel with 1 chres"
OMP_NUM_THREADS=1 ~/area-mp
```


run4.sh(4コアでの実行):

```sh
#!/bin/bash
echo "# Parallel with 4 cores"
OMP_NUM_THREADS=4 ~/area-mp
```

run16.sh(16コアでの実行):

```sh
#!/bin/bash
echo "# Parallel with 16 cores"
OMP_NUM_THREADS=16 ~/area-mp
```

作成したジョブスクリプトを計算サーバのOpenPBSに渡した。

逐次処理の実行結果:

```sh
u15232027@ryzen0:~$ qsub run.sh
3284.ryzen0
u15232027@ryzen0:~$ cat run.sh.o3284
# Serial processing
area * 4.0 = 3.1415926932000
time: 5.287167
```

1コアでの並列処理の実行結果:

```sh
u15232027@ryzen0:~$ qsub run1.sh
3276.ryzen0
u15232027@ryzen0:~$ cat run1.sh.o3276
# Parallel with 1 chres
area * 4.0 = 3.1415926932000
time: 5.317266
```

4コアでの並列処理の実行結果:

```sh
u15232027@ryzen0:~$ qsub run4.sh
3277.ryzen0
u15232027@ryzen0:~$ cat run4.sh.o3277
# Parallel with 4 cores
area * 4.0 = 3.1415926932000
time: 1.373160
```

16コアでの並列処理の実行結果:

```sh
u15232027@ryzen0:~$ qsub run16.sh
3278.ryzen0
u15232027@ryzen0:~$ cat run16.sh.o3278
# Parallel with 16 cores
area * 4.0 = 3.1415926932000
time: 0.651320
```

#### 計算結果(逐次処理での計算時間/xコアでの並列処理での計算時間)
- 逐次処理:5.287167
- 1コアの並列処理:5.317266(0.9943393)
- 4コアの並列処理:1.373160(3.850364)
- 16コアの並列処理:0.651320(8.11761)

1コアの並列処理だと逐次処理とほぼ変わらない結果になった。4コアの処理では逐次処理の時と比べ3.850364倍になったのは、コアの数が4倍になっているのと比例しているように見えるが速度の方がやや下振れている。16コアの並列処理では逐次処理の時と比べ8.11761倍になった。コアの数が16倍になったのに比例して16倍となるわけではなかった。  
並列処理ではコア数が多いほど速度は向上するが、コア数が多くなるほど速度の上昇が何かしらのボトルネックによって阻害されるようである。  
ボトルネックの要因としては並列化できない逐次処理部分がある事ではないかと考えたが、プログラム自体はほとんど並列化できているので疑わしい。


### 演習問題3.5:並列プログラムをジョブで実行2
y軸ループの並列化を行うためarea.cの2つ目のfor文の前に下記のディレクティブを追加した。

```c
#pragma omp parallel for private(j,x) reduction(+:s1)
```


1コアでの並列処理の実行結果:

```sh
u15232027@ryzen0:~$ qsub run1.sh
3297.ryzen0
u15232027@ryzen0:~$ cat run1.sh.o3297 
# Parallel with 1 chres
area * 4.0 = 3.1415926932000
time: 5.306080
```


4コアでの並列処理の実行結果:

```sh
u15232027@ryzen0:~$ qsub run4.sh
3298.ryzen0
u15232027@ryzen0:~$ cat run4.sh.o3298 
# Parallel with 4 cores
area * 4.0 = 3.1415926932000
time: 1.459103
```



16コアでの並列処理の実行結果:

```sh
u15232027@ryzen0:~$ qsub run16.sh
3299.ryzen0
u15232027@ryzen0:~$ cat run16.sh.o3299 
# Parallel with 16 cores
area * 4.0 = 3.1415926932000
time: 0.982607
```

### 計算結果(逐次処理での計算時間/xコアでの並列処理での計算時間)
- 逐次処理:5.287167
- y軸
  - 1コアの並列処理:5.317266(0.9943393)
  - 4コアの並列処理:1.373160(3.850364)
  - 16コアの並列処理:0.651320(8.11761) 
- x軸
  - 1コアの並列処理:5.306080(0.9964355)
  - 4コアの並列処理:1.459103(3.623573)
  - 16コアの並列処理:0.982607(5.38075) 

新たに行ったx軸の並列処理において、1コアの場合は逐次処理、y軸の場合と同様の結果となった。4コアの場合はy軸よりx軸の処理の方が0.08ほど遅かった。16コアの場合は0.3秒ほど遅かった。  
x軸の並列処理ではy軸の並列処理より遅く、コア数が多くなるほどその差が広がることが分かる。要因としてはx軸の並列処理の方が逐次処理部分が多くなる空だと考える。